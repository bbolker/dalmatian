---
title: "Analysis of the Pied Flycatcher Data"
author: "Simon Bonner"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

As a first example of the functions in this package we will fit a model to the pied flycatcher data. We will start by fitting a model with fixed effects on the mean and variance components. Specifically, we will model the load returned on each trip by the adult flycatchers a independent normal random variables with mean given by a linear combination of the logarithm of the inter-visit interval (IVI), the broodsize manipulation (broodsize), and the adult's sex, and standard deviation given by a linear combination of broodsize and sex, on the log scale. We will then incorporate individual random effects into this model. 

# Library

First you have to load the package:
```{r}
## Load package
library(dalmation)
```

# Raw data

The raw data for this example is provided in the package and can be accessed with:
```{r}
## Load pied flycatcher data
data(pied_flycatchers_1)
```
This data contains records on 5795 different food deliveries recorded during the pied flycatcher experiment. The response variable, `load`, records the load rounded to the nearest .1 gram. We want to model the logarithm of the load, and we also want to account for the rounding. To do this we will create two new variables in the data frame, `lower` and `upper`, which bound the logarithm of the true load. Note that we add .001 when the observed value is zero to avoid problems with the logarithm. 
```{r}
## Create variables bounding the true load
pfdata$lower=ifelse(pfdata$load==0,log(.001),log(pfdata$load-.049))
pfdata$upper=log(pfdata$load+.05)
```

# Model 1: Fixed Effects
Our initial model for the logarithm of the load returned on the $j$th trip by adult $i$  will be $N(\mu_{ij},\sigma_{ij}^2)$ where:
$$\mu=\beta_0 + \beta_1 \mathrm{log(IVI)_{ij} + \beta_2 broodsize_i + \beta_3 sex_i}$$
and
$$\log(\sigma)=\psi_0 + \psi_1 \mathrm{broodsize}_i + \psi_2\mathrm{sex}_i$$.

## Model

The first step is to define the models for the mean and variance components. These models are simply lists with (up to) two named components, `fixed` and `random`, which provide the details on the fixed and random effects. Both lists must contain a variable `name` specifying the basename for the coefficients and a variable `formula` specifying the effects. The `fixed` list should also contain an object called `priors` which specifies the priors for coefficients in the fixed effects portion of the model. Random effects are currently assumed to be normal with mean zero and unknown variances which are assigned the half $t$-distribution with ? degrees of freedom and scale ?. The optional parameter `link` can also be used to specify a link function for either component.

The components of the model for the pied flycatcher data specified above would be generated with:

```{r}
mymean=list(fixed=list(name="alpha",
       formula=~ log(IVI) + broodsize + sex,
       priors=list(c("dnorm",0,.001))))

myvar=list(fixed=list(name="psi",
      link="log",
      formula=~broodsize + sex,
      priors=list(c("dnorm",0,.001))))

```
These two objects will now be used to generate the JAGS code, data, and initial values for running the model.

## Running the Model with Dalmation

The primary function in the package `dalmation` automates the creation of the `JAGS` code, data, and initial values and then passes these to `JAGS` via the functions in the `rjags` package. The `dalmation` function takes requires several arguments including the data frame for the analysis, the model objects created above, and the name of the `JAGS` model file. It also requires two lists containing named arguments for the functions `jags.model` and `coda.samples` from the `rjags` package. Descriptions of the arguments for these two functions are available in their own help pages. Any arguments that are not specified in these lists will take the default values given by `rjags`. The two exceptions are the `file` argument of `jags.model` and the `n.iter` argument of `coda.samples` which do not have default values and must be specified. The number of parallel chains will be taken from the `jags.model` list. If this value is not specified then three chains will be run in order that convergence diagnostics can be computed.

```{r}

## Define list of arguments for jags.model()
jm.args <- list(file="pied_flycatcher_1_jags.R",n.adapt=100)

## Define list of arguments for coda.samples()
cs.args <- list(n.iter=100)

## Run the model using dalmation
pfresults <- dalmation(df=pfdata,
                          mean.model=mymean,
                          variance.model=myvar,
                          jags.model.args=jm.args,
                          coda.samples.args=cs.args,
                          rounding=TRUE,
                          lower="lower",
                          upper="upper",
                          debug=FALSE)

```

## Results
The function `dalmation` returns list containing three objects:
1. `jags.model.args`
   The full list of arguments passed to `jags.model`. This includes the variables in the input list along with the name of the model file, the formatted data, and the initial values.
2. `coda.samples.args`
   The full list of arguments passed to `coda.samples`. This includes the variables in the input list along with the complete object returned by `jags.model.args` and the character vector including the names of the monitored parameters.
3. `coda`
   An object of class `mcmc.list` and length `n.chains` containing the samples generated by `JAGS`. 

## Summaries
Summaries of the MCMC sampler and the posterior distribution can be constructed from `coda` with a variety of tools. For example, we can use the tools in the package `coda` to generate traceplots, density plots and histograms, numerical summaries of the posterior, and convergence diagnostics. The `ggmcmc` package can also be used to create fancier looking traceplots, density plots, and plots summarizing the posterior distribition in terms of posterior means and quantiles (credible intervals). 

First we will assess the convergence of the Markov chains using the function from the `coda` package.
```{r}
library(coda)

## Compute Gelman-Rubin Diagnostics
gelman.diag(pfresults$coda)

## Compute effective sample size
effectiveSize(pfresults$coda)
```
These results show that the chains have not converged well (GRB diagnostic values as high as 2.13 in my run) and samples that are equivalent to between 6 and 22 independent draws from the posterior. This is not surprising. I have set the number of burn-in and sampling iterations to be very small so that the sampler finishes quickly, but they are far, far too small for the chain to adapt, converge, and mix properly. 

Now we will examine the posterior distribution of the fixed effects of the mean component.
```{r}
library(ggmcmc)

## Examine fixed effects of mean component
ggs.mean=ggs(pfresults$coda,mymean$fixed$name)

ggs_traceplot(ggs.mean)
ggs_density(ggs.mean)
ggs_caterpillar(ggs.mean) + geom_vline(xintercept=0)
```
Then we examine the posterior distribution of the fixed effects of the variance component.
```{r}
## Examine fixed effects of variance component
ggs.var=ggs(pfresults$coda,myvar$fixed$name)

ggs_traceplot(ggs.var)
ggs_density(ggs.var)
ggs_caterpillar(ggs.var) + geom_vline(xintercept=0)
```

# Model 2: Random Effects

We will now consider adding individual (bird) random effects to both the fixed and random components of our model. This can be done by simply adding to the model components created above and then rerunnig the model. The new model will have mean and variance
$$\mu=\beta_0 + \beta_1 \mathrm{log(IVI)_{ij} + \beta_2 broodsize_i + \beta_3 sex_i + \epsilon_{i}}$$
and
$$\log(\sigma)=\psi_0 + \psi_1 \mathrm{broodsize}_i + \psi_2\mathrm{sex}_i + \xi_j$$
where $\epsilon_i \sim N(0,\tau^2_\mu)$ and $\xi_i \sim N(0,\tau^2_\sigma)$. By default the variances $\tau^2_{\epsilon}$ and $\tau^2_{\xi}$ are assigned half-$t$ prior distributions.

## Model

Instead of creating new model objects we can simply add to the old objects by creating the `random` fields. As with the fixed effects, these fields are lists which must include a basename for the random effects and formula specifying the random effects model.

```{r}
# Random component of mean
mymean$random=list(name="epsilon",formula=~-1 + indidx)

# Random component of variance
myvar$random=list(name="xi",formula=~-1 + indidx)
```

## Running the Model with Dalmation

The new model can now be run using `dalmation` in exactly the same way as above. However, we will make one change. In order to shorten the convergence time, we will base initial values on the results of the fixed effects model and then provide these as input. In particular, we will define initial values for the fixed effects of both the mean and variance components by taking the values from the final iterations of each of the chains run for the fixed effects model. For convenience, we set the random effects variances equal to 1 in all three chains. 


```{r}

## Define initial values
inits <- lapply(1:3,function(i){
                    list(alpha=pfresults$coda[[i]][100,1:4],
                         psi=pfresults$coda[[i]][100,5:7],
                         y=pfresults$jags.model.args$inits[[i]]$y,
                         tau.epsilon=1,
                         tau.xi=1)
                })

## Define list of arguments for jags.model()
jm.args <- list(file="pied_flycatcher_2_jags.R",inits=inits,n.adapt=100)

## Define list of arguments for coda.samples()
cs.args <- list(n.iter=100)

## Run the model using dalmation
pfresults2 <- dalmation(df=pfdata,
                           mean.model=mymean,
                           variance.model=myvar,
                           jags.model.args=jm.args,
                           coda.samples.args=cs.args,
                           rounding=TRUE,
                           lower="lower",
                           upper="upper",
                           debug=FALSE)

```

## Results
As before, we can examine the samples from the posterior distributions of the cofficients in the mean and variance components.

```{r}
## Gelman Diagnostics
gelman.diag(pfresults2$coda)
```

```{r}
## Examine fixed effects of mean component
ggs.mean=ggs(pfresults2$coda,paste0("^",mymean$fixed$name))

ggs_traceplot(ggs.mean)
ggs_density(ggs.mean)
ggs_caterpillar(ggs.mean) + geom_vline(xintercept=0)

## Examine fixed effects of variance component
ggs.var=ggs(pfresults2$coda,paste0("^",myvar$fixed$name))

ggs_traceplot(ggs.var)
ggs_density(ggs.var)
ggs_caterpillar(ggs.var) + geom_vline(xintercept=0)
```

We can also examine traceplots and posterior summaries for the standard deviations of the random effects.

```{r}
ggs.random=ggs(pfresults2$coda,family="sd")

ggs_traceplot(ggs.random)
ggs_density(ggs.random)
ggs_caterpillar(ggs.random)
```
